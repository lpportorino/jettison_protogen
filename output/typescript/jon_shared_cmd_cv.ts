// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.2
// source: jon_shared_cmd_cv.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  JonGuiDataVideoChannel,
  jonGuiDataVideoChannelFromJSON,
  jonGuiDataVideoChannelToJSON,
} from "./jon_shared_data_types";

export interface Root {
  setAutoFocus?: SetAutoFocus | undefined;
  startTrackNdc?: StartTrackNDC | undefined;
  stopTrack?: StopTrack | undefined;
  vampireModeEnable?: VampireModeEnable | undefined;
  vampireModeDisable?: VampireModeDisable | undefined;
  stabilizationModeEnable?: StabilizationModeEnable | undefined;
  stabilizationModeDisable?: StabilizationModeDisable | undefined;
  dumpStart?: DumpStart | undefined;
  dumpStop?: DumpStop | undefined;
  recognitionModeEnable?: RecognitionModeEnable | undefined;
  recognitionModeDisable?: RecognitionModeDisable | undefined;
}

export interface VampireModeEnable {
}

export interface DumpStart {
}

export interface DumpStop {
}

export interface VampireModeDisable {
}

export interface StabilizationModeEnable {
}

export interface StabilizationModeDisable {
}

export interface RecognitionModeEnable {
}

export interface RecognitionModeDisable {
}

export interface SetAutoFocus {
  channel: JonGuiDataVideoChannel;
  value: boolean;
}

export interface StartTrackNDC {
  channel: JonGuiDataVideoChannel;
  x: number;
  y: number;
  frameTime: Long;
  /** System monotonic time from state when user performed action */
  stateTime: Long;
}

export interface StopTrack {
}

function createBaseRoot(): Root {
  return {
    setAutoFocus: undefined,
    startTrackNdc: undefined,
    stopTrack: undefined,
    vampireModeEnable: undefined,
    vampireModeDisable: undefined,
    stabilizationModeEnable: undefined,
    stabilizationModeDisable: undefined,
    dumpStart: undefined,
    dumpStop: undefined,
    recognitionModeEnable: undefined,
    recognitionModeDisable: undefined,
  };
}

export const Root: MessageFns<Root> = {
  encode(message: Root, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.setAutoFocus !== undefined) {
      SetAutoFocus.encode(message.setAutoFocus, writer.uint32(10).fork()).join();
    }
    if (message.startTrackNdc !== undefined) {
      StartTrackNDC.encode(message.startTrackNdc, writer.uint32(18).fork()).join();
    }
    if (message.stopTrack !== undefined) {
      StopTrack.encode(message.stopTrack, writer.uint32(26).fork()).join();
    }
    if (message.vampireModeEnable !== undefined) {
      VampireModeEnable.encode(message.vampireModeEnable, writer.uint32(34).fork()).join();
    }
    if (message.vampireModeDisable !== undefined) {
      VampireModeDisable.encode(message.vampireModeDisable, writer.uint32(42).fork()).join();
    }
    if (message.stabilizationModeEnable !== undefined) {
      StabilizationModeEnable.encode(message.stabilizationModeEnable, writer.uint32(50).fork()).join();
    }
    if (message.stabilizationModeDisable !== undefined) {
      StabilizationModeDisable.encode(message.stabilizationModeDisable, writer.uint32(58).fork()).join();
    }
    if (message.dumpStart !== undefined) {
      DumpStart.encode(message.dumpStart, writer.uint32(66).fork()).join();
    }
    if (message.dumpStop !== undefined) {
      DumpStop.encode(message.dumpStop, writer.uint32(74).fork()).join();
    }
    if (message.recognitionModeEnable !== undefined) {
      RecognitionModeEnable.encode(message.recognitionModeEnable, writer.uint32(82).fork()).join();
    }
    if (message.recognitionModeDisable !== undefined) {
      RecognitionModeDisable.encode(message.recognitionModeDisable, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Root {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.setAutoFocus = SetAutoFocus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startTrackNdc = StartTrackNDC.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stopTrack = StopTrack.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vampireModeEnable = VampireModeEnable.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.vampireModeDisable = VampireModeDisable.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.stabilizationModeEnable = StabilizationModeEnable.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stabilizationModeDisable = StabilizationModeDisable.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dumpStart = DumpStart.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dumpStop = DumpStop.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.recognitionModeEnable = RecognitionModeEnable.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.recognitionModeDisable = RecognitionModeDisable.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Root {
    return {
      setAutoFocus: isSet(object.setAutoFocus) ? SetAutoFocus.fromJSON(object.setAutoFocus) : undefined,
      startTrackNdc: isSet(object.startTrackNdc) ? StartTrackNDC.fromJSON(object.startTrackNdc) : undefined,
      stopTrack: isSet(object.stopTrack) ? StopTrack.fromJSON(object.stopTrack) : undefined,
      vampireModeEnable: isSet(object.vampireModeEnable)
        ? VampireModeEnable.fromJSON(object.vampireModeEnable)
        : undefined,
      vampireModeDisable: isSet(object.vampireModeDisable)
        ? VampireModeDisable.fromJSON(object.vampireModeDisable)
        : undefined,
      stabilizationModeEnable: isSet(object.stabilizationModeEnable)
        ? StabilizationModeEnable.fromJSON(object.stabilizationModeEnable)
        : undefined,
      stabilizationModeDisable: isSet(object.stabilizationModeDisable)
        ? StabilizationModeDisable.fromJSON(object.stabilizationModeDisable)
        : undefined,
      dumpStart: isSet(object.dumpStart) ? DumpStart.fromJSON(object.dumpStart) : undefined,
      dumpStop: isSet(object.dumpStop) ? DumpStop.fromJSON(object.dumpStop) : undefined,
      recognitionModeEnable: isSet(object.recognitionModeEnable)
        ? RecognitionModeEnable.fromJSON(object.recognitionModeEnable)
        : undefined,
      recognitionModeDisable: isSet(object.recognitionModeDisable)
        ? RecognitionModeDisable.fromJSON(object.recognitionModeDisable)
        : undefined,
    };
  },

  toJSON(message: Root): unknown {
    const obj: any = {};
    if (message.setAutoFocus !== undefined) {
      obj.setAutoFocus = SetAutoFocus.toJSON(message.setAutoFocus);
    }
    if (message.startTrackNdc !== undefined) {
      obj.startTrackNdc = StartTrackNDC.toJSON(message.startTrackNdc);
    }
    if (message.stopTrack !== undefined) {
      obj.stopTrack = StopTrack.toJSON(message.stopTrack);
    }
    if (message.vampireModeEnable !== undefined) {
      obj.vampireModeEnable = VampireModeEnable.toJSON(message.vampireModeEnable);
    }
    if (message.vampireModeDisable !== undefined) {
      obj.vampireModeDisable = VampireModeDisable.toJSON(message.vampireModeDisable);
    }
    if (message.stabilizationModeEnable !== undefined) {
      obj.stabilizationModeEnable = StabilizationModeEnable.toJSON(message.stabilizationModeEnable);
    }
    if (message.stabilizationModeDisable !== undefined) {
      obj.stabilizationModeDisable = StabilizationModeDisable.toJSON(message.stabilizationModeDisable);
    }
    if (message.dumpStart !== undefined) {
      obj.dumpStart = DumpStart.toJSON(message.dumpStart);
    }
    if (message.dumpStop !== undefined) {
      obj.dumpStop = DumpStop.toJSON(message.dumpStop);
    }
    if (message.recognitionModeEnable !== undefined) {
      obj.recognitionModeEnable = RecognitionModeEnable.toJSON(message.recognitionModeEnable);
    }
    if (message.recognitionModeDisable !== undefined) {
      obj.recognitionModeDisable = RecognitionModeDisable.toJSON(message.recognitionModeDisable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Root>, I>>(base?: I): Root {
    return Root.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Root>, I>>(object: I): Root {
    const message = createBaseRoot();
    message.setAutoFocus = (object.setAutoFocus !== undefined && object.setAutoFocus !== null)
      ? SetAutoFocus.fromPartial(object.setAutoFocus)
      : undefined;
    message.startTrackNdc = (object.startTrackNdc !== undefined && object.startTrackNdc !== null)
      ? StartTrackNDC.fromPartial(object.startTrackNdc)
      : undefined;
    message.stopTrack = (object.stopTrack !== undefined && object.stopTrack !== null)
      ? StopTrack.fromPartial(object.stopTrack)
      : undefined;
    message.vampireModeEnable = (object.vampireModeEnable !== undefined && object.vampireModeEnable !== null)
      ? VampireModeEnable.fromPartial(object.vampireModeEnable)
      : undefined;
    message.vampireModeDisable = (object.vampireModeDisable !== undefined && object.vampireModeDisable !== null)
      ? VampireModeDisable.fromPartial(object.vampireModeDisable)
      : undefined;
    message.stabilizationModeEnable =
      (object.stabilizationModeEnable !== undefined && object.stabilizationModeEnable !== null)
        ? StabilizationModeEnable.fromPartial(object.stabilizationModeEnable)
        : undefined;
    message.stabilizationModeDisable =
      (object.stabilizationModeDisable !== undefined && object.stabilizationModeDisable !== null)
        ? StabilizationModeDisable.fromPartial(object.stabilizationModeDisable)
        : undefined;
    message.dumpStart = (object.dumpStart !== undefined && object.dumpStart !== null)
      ? DumpStart.fromPartial(object.dumpStart)
      : undefined;
    message.dumpStop = (object.dumpStop !== undefined && object.dumpStop !== null)
      ? DumpStop.fromPartial(object.dumpStop)
      : undefined;
    message.recognitionModeEnable =
      (object.recognitionModeEnable !== undefined && object.recognitionModeEnable !== null)
        ? RecognitionModeEnable.fromPartial(object.recognitionModeEnable)
        : undefined;
    message.recognitionModeDisable =
      (object.recognitionModeDisable !== undefined && object.recognitionModeDisable !== null)
        ? RecognitionModeDisable.fromPartial(object.recognitionModeDisable)
        : undefined;
    return message;
  },
};

function createBaseVampireModeEnable(): VampireModeEnable {
  return {};
}

export const VampireModeEnable: MessageFns<VampireModeEnable> = {
  encode(_: VampireModeEnable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VampireModeEnable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVampireModeEnable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): VampireModeEnable {
    return {};
  },

  toJSON(_: VampireModeEnable): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<VampireModeEnable>, I>>(base?: I): VampireModeEnable {
    return VampireModeEnable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VampireModeEnable>, I>>(_: I): VampireModeEnable {
    const message = createBaseVampireModeEnable();
    return message;
  },
};

function createBaseDumpStart(): DumpStart {
  return {};
}

export const DumpStart: MessageFns<DumpStart> = {
  encode(_: DumpStart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DumpStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDumpStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DumpStart {
    return {};
  },

  toJSON(_: DumpStart): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DumpStart>, I>>(base?: I): DumpStart {
    return DumpStart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DumpStart>, I>>(_: I): DumpStart {
    const message = createBaseDumpStart();
    return message;
  },
};

function createBaseDumpStop(): DumpStop {
  return {};
}

export const DumpStop: MessageFns<DumpStop> = {
  encode(_: DumpStop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DumpStop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDumpStop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DumpStop {
    return {};
  },

  toJSON(_: DumpStop): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DumpStop>, I>>(base?: I): DumpStop {
    return DumpStop.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DumpStop>, I>>(_: I): DumpStop {
    const message = createBaseDumpStop();
    return message;
  },
};

function createBaseVampireModeDisable(): VampireModeDisable {
  return {};
}

export const VampireModeDisable: MessageFns<VampireModeDisable> = {
  encode(_: VampireModeDisable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VampireModeDisable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVampireModeDisable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): VampireModeDisable {
    return {};
  },

  toJSON(_: VampireModeDisable): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<VampireModeDisable>, I>>(base?: I): VampireModeDisable {
    return VampireModeDisable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VampireModeDisable>, I>>(_: I): VampireModeDisable {
    const message = createBaseVampireModeDisable();
    return message;
  },
};

function createBaseStabilizationModeEnable(): StabilizationModeEnable {
  return {};
}

export const StabilizationModeEnable: MessageFns<StabilizationModeEnable> = {
  encode(_: StabilizationModeEnable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StabilizationModeEnable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStabilizationModeEnable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StabilizationModeEnable {
    return {};
  },

  toJSON(_: StabilizationModeEnable): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StabilizationModeEnable>, I>>(base?: I): StabilizationModeEnable {
    return StabilizationModeEnable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StabilizationModeEnable>, I>>(_: I): StabilizationModeEnable {
    const message = createBaseStabilizationModeEnable();
    return message;
  },
};

function createBaseStabilizationModeDisable(): StabilizationModeDisable {
  return {};
}

export const StabilizationModeDisable: MessageFns<StabilizationModeDisable> = {
  encode(_: StabilizationModeDisable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StabilizationModeDisable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStabilizationModeDisable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StabilizationModeDisable {
    return {};
  },

  toJSON(_: StabilizationModeDisable): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StabilizationModeDisable>, I>>(base?: I): StabilizationModeDisable {
    return StabilizationModeDisable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StabilizationModeDisable>, I>>(_: I): StabilizationModeDisable {
    const message = createBaseStabilizationModeDisable();
    return message;
  },
};

function createBaseRecognitionModeEnable(): RecognitionModeEnable {
  return {};
}

export const RecognitionModeEnable: MessageFns<RecognitionModeEnable> = {
  encode(_: RecognitionModeEnable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecognitionModeEnable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecognitionModeEnable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RecognitionModeEnable {
    return {};
  },

  toJSON(_: RecognitionModeEnable): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RecognitionModeEnable>, I>>(base?: I): RecognitionModeEnable {
    return RecognitionModeEnable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecognitionModeEnable>, I>>(_: I): RecognitionModeEnable {
    const message = createBaseRecognitionModeEnable();
    return message;
  },
};

function createBaseRecognitionModeDisable(): RecognitionModeDisable {
  return {};
}

export const RecognitionModeDisable: MessageFns<RecognitionModeDisable> = {
  encode(_: RecognitionModeDisable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecognitionModeDisable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecognitionModeDisable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RecognitionModeDisable {
    return {};
  },

  toJSON(_: RecognitionModeDisable): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RecognitionModeDisable>, I>>(base?: I): RecognitionModeDisable {
    return RecognitionModeDisable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecognitionModeDisable>, I>>(_: I): RecognitionModeDisable {
    const message = createBaseRecognitionModeDisable();
    return message;
  },
};

function createBaseSetAutoFocus(): SetAutoFocus {
  return { channel: 0, value: false };
}

export const SetAutoFocus: MessageFns<SetAutoFocus> = {
  encode(message: SetAutoFocus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== 0) {
      writer.uint32(8).int32(message.channel);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAutoFocus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAutoFocus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAutoFocus {
    return {
      channel: isSet(object.channel) ? jonGuiDataVideoChannelFromJSON(object.channel) : 0,
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: SetAutoFocus): unknown {
    const obj: any = {};
    if (message.channel !== 0) {
      obj.channel = jonGuiDataVideoChannelToJSON(message.channel);
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetAutoFocus>, I>>(base?: I): SetAutoFocus {
    return SetAutoFocus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetAutoFocus>, I>>(object: I): SetAutoFocus {
    const message = createBaseSetAutoFocus();
    message.channel = object.channel ?? 0;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseStartTrackNDC(): StartTrackNDC {
  return { channel: 0, x: 0, y: 0, frameTime: Long.UZERO, stateTime: Long.UZERO };
}

export const StartTrackNDC: MessageFns<StartTrackNDC> = {
  encode(message: StartTrackNDC, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== 0) {
      writer.uint32(8).int32(message.channel);
    }
    if (message.x !== 0) {
      writer.uint32(17).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(25).double(message.y);
    }
    if (!message.frameTime.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.frameTime.toString());
    }
    if (!message.stateTime.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.stateTime.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTrackNDC {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTrackNDC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.y = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.frameTime = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.stateTime = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTrackNDC {
    return {
      channel: isSet(object.channel) ? jonGuiDataVideoChannelFromJSON(object.channel) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      frameTime: isSet(object.frameTime) ? Long.fromValue(object.frameTime) : Long.UZERO,
      stateTime: isSet(object.stateTime) ? Long.fromValue(object.stateTime) : Long.UZERO,
    };
  },

  toJSON(message: StartTrackNDC): unknown {
    const obj: any = {};
    if (message.channel !== 0) {
      obj.channel = jonGuiDataVideoChannelToJSON(message.channel);
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (!message.frameTime.equals(Long.UZERO)) {
      obj.frameTime = (message.frameTime || Long.UZERO).toString();
    }
    if (!message.stateTime.equals(Long.UZERO)) {
      obj.stateTime = (message.stateTime || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartTrackNDC>, I>>(base?: I): StartTrackNDC {
    return StartTrackNDC.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartTrackNDC>, I>>(object: I): StartTrackNDC {
    const message = createBaseStartTrackNDC();
    message.channel = object.channel ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.frameTime = (object.frameTime !== undefined && object.frameTime !== null)
      ? Long.fromValue(object.frameTime)
      : Long.UZERO;
    message.stateTime = (object.stateTime !== undefined && object.stateTime !== null)
      ? Long.fromValue(object.stateTime)
      : Long.UZERO;
    return message;
  },
};

function createBaseStopTrack(): StopTrack {
  return {};
}

export const StopTrack: MessageFns<StopTrack> = {
  encode(_: StopTrack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopTrack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StopTrack {
    return {};
  },

  toJSON(_: StopTrack): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<StopTrack>, I>>(base?: I): StopTrack {
    return StopTrack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopTrack>, I>>(_: I): StopTrack {
    const message = createBaseStopTrack();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
