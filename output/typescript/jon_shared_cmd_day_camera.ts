// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.2
// source: jon_shared_cmd_day_camera.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { JonGuiDataFxModeDay, jonGuiDataFxModeDayFromJSON, jonGuiDataFxModeDayToJSON } from "./jon_shared_data_types";

export interface SetValue {
  value: number;
}

export interface Move {
  targetValue: number;
  speed: number;
}

export interface Offset {
  offsetValue: number;
}

export interface SetClaheLevel {
  value: number;
}

export interface ShiftClaheLevel {
  value: number;
}

export interface Root {
  focus?: Focus | undefined;
  zoom?: Zoom | undefined;
  setIris?: SetIris | undefined;
  setInfraRedFilter?: SetInfraRedFilter | undefined;
  start?: Start | undefined;
  stop?: Stop | undefined;
  photo?: Photo | undefined;
  setAutoIris?: SetAutoIris | undefined;
  haltAll?: HaltAll | undefined;
  setFxMode?: SetFxMode | undefined;
  nextFxMode?: NextFxMode | undefined;
  prevFxMode?: PrevFxMode | undefined;
  getMeteo?: GetMeteo | undefined;
  refreshFxMode?: RefreshFxMode | undefined;
  setDigitalZoomLevel?: SetDigitalZoomLevel | undefined;
  setClaheLevel?: SetClaheLevel | undefined;
  shiftClaheLevel?: ShiftClaheLevel | undefined;
  focusAtRoi?: FocusAtROI | undefined;
  trackRoi?: TrackROI | undefined;
  zoomRoi?: ZoomROI | undefined;
}

export interface GetPos {
}

export interface NextFxMode {
}

export interface PrevFxMode {
}

export interface RefreshFxMode {
}

export interface HaltAll {
}

export interface SetFxMode {
  mode: JonGuiDataFxModeDay;
}

export interface SetDigitalZoomLevel {
  value: number;
}

export interface Focus {
  setValue?: SetValue | undefined;
  move?: Move | undefined;
  halt?: Halt | undefined;
  offset?: Offset | undefined;
  resetFocus?: ResetFocus | undefined;
  saveToTableFocus?: SaveToTableFocus | undefined;
}

export interface Zoom {
  setValue?: SetValue | undefined;
  move?: Move | undefined;
  halt?: Halt | undefined;
  setZoomTableValue?: SetZoomTableValue | undefined;
  nextZoomTablePos?: NextZoomTablePos | undefined;
  prevZoomTablePos?: PrevZoomTablePos | undefined;
  offset?: Offset | undefined;
  resetZoom?: ResetZoom | undefined;
  saveToTable?: SaveToTable | undefined;
}

export interface NextZoomTablePos {
}

export interface PrevZoomTablePos {
}

export interface SetIris {
  value: number;
}

export interface SetInfraRedFilter {
  value: boolean;
}

export interface SetAutoIris {
  value: boolean;
}

export interface SetZoomTableValue {
  value: number;
}

export interface Stop {
}

export interface Start {
}

export interface Photo {
}

export interface Halt {
}

export interface GetMeteo {
}

export interface ResetZoom {
}

export interface ResetFocus {
}

export interface SaveToTable {
}

export interface SaveToTableFocus {
}

export interface FocusAtROI {
  x: number;
  y: number;
}

export interface TrackROI {
  x1: number;
  y1: number;
  x2: number;
  y2: number;
}

export interface ZoomROI {
  x1: number;
  y1: number;
  x2: number;
  y2: number;
}

function createBaseSetValue(): SetValue {
  return { value: 0 };
}

export const SetValue: MessageFns<SetValue> = {
  encode(message: SetValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetValue {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: SetValue): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetValue>, I>>(base?: I): SetValue {
    return SetValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetValue>, I>>(object: I): SetValue {
    const message = createBaseSetValue();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMove(): Move {
  return { targetValue: 0, speed: 0 };
}

export const Move: MessageFns<Move> = {
  encode(message: Move, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetValue !== 0) {
      writer.uint32(9).double(message.targetValue);
    }
    if (message.speed !== 0) {
      writer.uint32(17).double(message.speed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Move {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.targetValue = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.speed = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Move {
    return {
      targetValue: isSet(object.targetValue) ? globalThis.Number(object.targetValue) : 0,
      speed: isSet(object.speed) ? globalThis.Number(object.speed) : 0,
    };
  },

  toJSON(message: Move): unknown {
    const obj: any = {};
    if (message.targetValue !== 0) {
      obj.targetValue = message.targetValue;
    }
    if (message.speed !== 0) {
      obj.speed = message.speed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Move>, I>>(base?: I): Move {
    return Move.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Move>, I>>(object: I): Move {
    const message = createBaseMove();
    message.targetValue = object.targetValue ?? 0;
    message.speed = object.speed ?? 0;
    return message;
  },
};

function createBaseOffset(): Offset {
  return { offsetValue: 0 };
}

export const Offset: MessageFns<Offset> = {
  encode(message: Offset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offsetValue !== 0) {
      writer.uint32(9).double(message.offsetValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Offset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOffset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.offsetValue = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Offset {
    return { offsetValue: isSet(object.offsetValue) ? globalThis.Number(object.offsetValue) : 0 };
  },

  toJSON(message: Offset): unknown {
    const obj: any = {};
    if (message.offsetValue !== 0) {
      obj.offsetValue = message.offsetValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Offset>, I>>(base?: I): Offset {
    return Offset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Offset>, I>>(object: I): Offset {
    const message = createBaseOffset();
    message.offsetValue = object.offsetValue ?? 0;
    return message;
  },
};

function createBaseSetClaheLevel(): SetClaheLevel {
  return { value: 0 };
}

export const SetClaheLevel: MessageFns<SetClaheLevel> = {
  encode(message: SetClaheLevel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetClaheLevel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetClaheLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetClaheLevel {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: SetClaheLevel): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetClaheLevel>, I>>(base?: I): SetClaheLevel {
    return SetClaheLevel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetClaheLevel>, I>>(object: I): SetClaheLevel {
    const message = createBaseSetClaheLevel();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseShiftClaheLevel(): ShiftClaheLevel {
  return { value: 0 };
}

export const ShiftClaheLevel: MessageFns<ShiftClaheLevel> = {
  encode(message: ShiftClaheLevel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShiftClaheLevel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShiftClaheLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShiftClaheLevel {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: ShiftClaheLevel): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShiftClaheLevel>, I>>(base?: I): ShiftClaheLevel {
    return ShiftClaheLevel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShiftClaheLevel>, I>>(object: I): ShiftClaheLevel {
    const message = createBaseShiftClaheLevel();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseRoot(): Root {
  return {
    focus: undefined,
    zoom: undefined,
    setIris: undefined,
    setInfraRedFilter: undefined,
    start: undefined,
    stop: undefined,
    photo: undefined,
    setAutoIris: undefined,
    haltAll: undefined,
    setFxMode: undefined,
    nextFxMode: undefined,
    prevFxMode: undefined,
    getMeteo: undefined,
    refreshFxMode: undefined,
    setDigitalZoomLevel: undefined,
    setClaheLevel: undefined,
    shiftClaheLevel: undefined,
    focusAtRoi: undefined,
    trackRoi: undefined,
    zoomRoi: undefined,
  };
}

export const Root: MessageFns<Root> = {
  encode(message: Root, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.focus !== undefined) {
      Focus.encode(message.focus, writer.uint32(10).fork()).join();
    }
    if (message.zoom !== undefined) {
      Zoom.encode(message.zoom, writer.uint32(18).fork()).join();
    }
    if (message.setIris !== undefined) {
      SetIris.encode(message.setIris, writer.uint32(26).fork()).join();
    }
    if (message.setInfraRedFilter !== undefined) {
      SetInfraRedFilter.encode(message.setInfraRedFilter, writer.uint32(34).fork()).join();
    }
    if (message.start !== undefined) {
      Start.encode(message.start, writer.uint32(42).fork()).join();
    }
    if (message.stop !== undefined) {
      Stop.encode(message.stop, writer.uint32(50).fork()).join();
    }
    if (message.photo !== undefined) {
      Photo.encode(message.photo, writer.uint32(58).fork()).join();
    }
    if (message.setAutoIris !== undefined) {
      SetAutoIris.encode(message.setAutoIris, writer.uint32(66).fork()).join();
    }
    if (message.haltAll !== undefined) {
      HaltAll.encode(message.haltAll, writer.uint32(74).fork()).join();
    }
    if (message.setFxMode !== undefined) {
      SetFxMode.encode(message.setFxMode, writer.uint32(82).fork()).join();
    }
    if (message.nextFxMode !== undefined) {
      NextFxMode.encode(message.nextFxMode, writer.uint32(90).fork()).join();
    }
    if (message.prevFxMode !== undefined) {
      PrevFxMode.encode(message.prevFxMode, writer.uint32(98).fork()).join();
    }
    if (message.getMeteo !== undefined) {
      GetMeteo.encode(message.getMeteo, writer.uint32(106).fork()).join();
    }
    if (message.refreshFxMode !== undefined) {
      RefreshFxMode.encode(message.refreshFxMode, writer.uint32(114).fork()).join();
    }
    if (message.setDigitalZoomLevel !== undefined) {
      SetDigitalZoomLevel.encode(message.setDigitalZoomLevel, writer.uint32(122).fork()).join();
    }
    if (message.setClaheLevel !== undefined) {
      SetClaheLevel.encode(message.setClaheLevel, writer.uint32(130).fork()).join();
    }
    if (message.shiftClaheLevel !== undefined) {
      ShiftClaheLevel.encode(message.shiftClaheLevel, writer.uint32(138).fork()).join();
    }
    if (message.focusAtRoi !== undefined) {
      FocusAtROI.encode(message.focusAtRoi, writer.uint32(146).fork()).join();
    }
    if (message.trackRoi !== undefined) {
      TrackROI.encode(message.trackRoi, writer.uint32(154).fork()).join();
    }
    if (message.zoomRoi !== undefined) {
      ZoomROI.encode(message.zoomRoi, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Root {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.focus = Focus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.zoom = Zoom.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.setIris = SetIris.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.setInfraRedFilter = SetInfraRedFilter.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.start = Start.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.stop = Stop.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.photo = Photo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.setAutoIris = SetAutoIris.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.haltAll = HaltAll.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.setFxMode = SetFxMode.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.nextFxMode = NextFxMode.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.prevFxMode = PrevFxMode.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.getMeteo = GetMeteo.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.refreshFxMode = RefreshFxMode.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.setDigitalZoomLevel = SetDigitalZoomLevel.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.setClaheLevel = SetClaheLevel.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.shiftClaheLevel = ShiftClaheLevel.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.focusAtRoi = FocusAtROI.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.trackRoi = TrackROI.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.zoomRoi = ZoomROI.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Root {
    return {
      focus: isSet(object.focus) ? Focus.fromJSON(object.focus) : undefined,
      zoom: isSet(object.zoom) ? Zoom.fromJSON(object.zoom) : undefined,
      setIris: isSet(object.setIris) ? SetIris.fromJSON(object.setIris) : undefined,
      setInfraRedFilter: isSet(object.setInfraRedFilter)
        ? SetInfraRedFilter.fromJSON(object.setInfraRedFilter)
        : undefined,
      start: isSet(object.start) ? Start.fromJSON(object.start) : undefined,
      stop: isSet(object.stop) ? Stop.fromJSON(object.stop) : undefined,
      photo: isSet(object.photo) ? Photo.fromJSON(object.photo) : undefined,
      setAutoIris: isSet(object.setAutoIris) ? SetAutoIris.fromJSON(object.setAutoIris) : undefined,
      haltAll: isSet(object.haltAll) ? HaltAll.fromJSON(object.haltAll) : undefined,
      setFxMode: isSet(object.setFxMode) ? SetFxMode.fromJSON(object.setFxMode) : undefined,
      nextFxMode: isSet(object.nextFxMode) ? NextFxMode.fromJSON(object.nextFxMode) : undefined,
      prevFxMode: isSet(object.prevFxMode) ? PrevFxMode.fromJSON(object.prevFxMode) : undefined,
      getMeteo: isSet(object.getMeteo) ? GetMeteo.fromJSON(object.getMeteo) : undefined,
      refreshFxMode: isSet(object.refreshFxMode) ? RefreshFxMode.fromJSON(object.refreshFxMode) : undefined,
      setDigitalZoomLevel: isSet(object.setDigitalZoomLevel)
        ? SetDigitalZoomLevel.fromJSON(object.setDigitalZoomLevel)
        : undefined,
      setClaheLevel: isSet(object.setClaheLevel) ? SetClaheLevel.fromJSON(object.setClaheLevel) : undefined,
      shiftClaheLevel: isSet(object.shiftClaheLevel) ? ShiftClaheLevel.fromJSON(object.shiftClaheLevel) : undefined,
      focusAtRoi: isSet(object.focusAtRoi) ? FocusAtROI.fromJSON(object.focusAtRoi) : undefined,
      trackRoi: isSet(object.trackRoi) ? TrackROI.fromJSON(object.trackRoi) : undefined,
      zoomRoi: isSet(object.zoomRoi) ? ZoomROI.fromJSON(object.zoomRoi) : undefined,
    };
  },

  toJSON(message: Root): unknown {
    const obj: any = {};
    if (message.focus !== undefined) {
      obj.focus = Focus.toJSON(message.focus);
    }
    if (message.zoom !== undefined) {
      obj.zoom = Zoom.toJSON(message.zoom);
    }
    if (message.setIris !== undefined) {
      obj.setIris = SetIris.toJSON(message.setIris);
    }
    if (message.setInfraRedFilter !== undefined) {
      obj.setInfraRedFilter = SetInfraRedFilter.toJSON(message.setInfraRedFilter);
    }
    if (message.start !== undefined) {
      obj.start = Start.toJSON(message.start);
    }
    if (message.stop !== undefined) {
      obj.stop = Stop.toJSON(message.stop);
    }
    if (message.photo !== undefined) {
      obj.photo = Photo.toJSON(message.photo);
    }
    if (message.setAutoIris !== undefined) {
      obj.setAutoIris = SetAutoIris.toJSON(message.setAutoIris);
    }
    if (message.haltAll !== undefined) {
      obj.haltAll = HaltAll.toJSON(message.haltAll);
    }
    if (message.setFxMode !== undefined) {
      obj.setFxMode = SetFxMode.toJSON(message.setFxMode);
    }
    if (message.nextFxMode !== undefined) {
      obj.nextFxMode = NextFxMode.toJSON(message.nextFxMode);
    }
    if (message.prevFxMode !== undefined) {
      obj.prevFxMode = PrevFxMode.toJSON(message.prevFxMode);
    }
    if (message.getMeteo !== undefined) {
      obj.getMeteo = GetMeteo.toJSON(message.getMeteo);
    }
    if (message.refreshFxMode !== undefined) {
      obj.refreshFxMode = RefreshFxMode.toJSON(message.refreshFxMode);
    }
    if (message.setDigitalZoomLevel !== undefined) {
      obj.setDigitalZoomLevel = SetDigitalZoomLevel.toJSON(message.setDigitalZoomLevel);
    }
    if (message.setClaheLevel !== undefined) {
      obj.setClaheLevel = SetClaheLevel.toJSON(message.setClaheLevel);
    }
    if (message.shiftClaheLevel !== undefined) {
      obj.shiftClaheLevel = ShiftClaheLevel.toJSON(message.shiftClaheLevel);
    }
    if (message.focusAtRoi !== undefined) {
      obj.focusAtRoi = FocusAtROI.toJSON(message.focusAtRoi);
    }
    if (message.trackRoi !== undefined) {
      obj.trackRoi = TrackROI.toJSON(message.trackRoi);
    }
    if (message.zoomRoi !== undefined) {
      obj.zoomRoi = ZoomROI.toJSON(message.zoomRoi);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Root>, I>>(base?: I): Root {
    return Root.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Root>, I>>(object: I): Root {
    const message = createBaseRoot();
    message.focus = (object.focus !== undefined && object.focus !== null) ? Focus.fromPartial(object.focus) : undefined;
    message.zoom = (object.zoom !== undefined && object.zoom !== null) ? Zoom.fromPartial(object.zoom) : undefined;
    message.setIris = (object.setIris !== undefined && object.setIris !== null)
      ? SetIris.fromPartial(object.setIris)
      : undefined;
    message.setInfraRedFilter = (object.setInfraRedFilter !== undefined && object.setInfraRedFilter !== null)
      ? SetInfraRedFilter.fromPartial(object.setInfraRedFilter)
      : undefined;
    message.start = (object.start !== undefined && object.start !== null) ? Start.fromPartial(object.start) : undefined;
    message.stop = (object.stop !== undefined && object.stop !== null) ? Stop.fromPartial(object.stop) : undefined;
    message.photo = (object.photo !== undefined && object.photo !== null) ? Photo.fromPartial(object.photo) : undefined;
    message.setAutoIris = (object.setAutoIris !== undefined && object.setAutoIris !== null)
      ? SetAutoIris.fromPartial(object.setAutoIris)
      : undefined;
    message.haltAll = (object.haltAll !== undefined && object.haltAll !== null)
      ? HaltAll.fromPartial(object.haltAll)
      : undefined;
    message.setFxMode = (object.setFxMode !== undefined && object.setFxMode !== null)
      ? SetFxMode.fromPartial(object.setFxMode)
      : undefined;
    message.nextFxMode = (object.nextFxMode !== undefined && object.nextFxMode !== null)
      ? NextFxMode.fromPartial(object.nextFxMode)
      : undefined;
    message.prevFxMode = (object.prevFxMode !== undefined && object.prevFxMode !== null)
      ? PrevFxMode.fromPartial(object.prevFxMode)
      : undefined;
    message.getMeteo = (object.getMeteo !== undefined && object.getMeteo !== null)
      ? GetMeteo.fromPartial(object.getMeteo)
      : undefined;
    message.refreshFxMode = (object.refreshFxMode !== undefined && object.refreshFxMode !== null)
      ? RefreshFxMode.fromPartial(object.refreshFxMode)
      : undefined;
    message.setDigitalZoomLevel = (object.setDigitalZoomLevel !== undefined && object.setDigitalZoomLevel !== null)
      ? SetDigitalZoomLevel.fromPartial(object.setDigitalZoomLevel)
      : undefined;
    message.setClaheLevel = (object.setClaheLevel !== undefined && object.setClaheLevel !== null)
      ? SetClaheLevel.fromPartial(object.setClaheLevel)
      : undefined;
    message.shiftClaheLevel = (object.shiftClaheLevel !== undefined && object.shiftClaheLevel !== null)
      ? ShiftClaheLevel.fromPartial(object.shiftClaheLevel)
      : undefined;
    message.focusAtRoi = (object.focusAtRoi !== undefined && object.focusAtRoi !== null)
      ? FocusAtROI.fromPartial(object.focusAtRoi)
      : undefined;
    message.trackRoi = (object.trackRoi !== undefined && object.trackRoi !== null)
      ? TrackROI.fromPartial(object.trackRoi)
      : undefined;
    message.zoomRoi = (object.zoomRoi !== undefined && object.zoomRoi !== null)
      ? ZoomROI.fromPartial(object.zoomRoi)
      : undefined;
    return message;
  },
};

function createBaseGetPos(): GetPos {
  return {};
}

export const GetPos: MessageFns<GetPos> = {
  encode(_: GetPos, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPos {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPos();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetPos {
    return {};
  },

  toJSON(_: GetPos): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPos>, I>>(base?: I): GetPos {
    return GetPos.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPos>, I>>(_: I): GetPos {
    const message = createBaseGetPos();
    return message;
  },
};

function createBaseNextFxMode(): NextFxMode {
  return {};
}

export const NextFxMode: MessageFns<NextFxMode> = {
  encode(_: NextFxMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NextFxMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNextFxMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NextFxMode {
    return {};
  },

  toJSON(_: NextFxMode): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NextFxMode>, I>>(base?: I): NextFxMode {
    return NextFxMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NextFxMode>, I>>(_: I): NextFxMode {
    const message = createBaseNextFxMode();
    return message;
  },
};

function createBasePrevFxMode(): PrevFxMode {
  return {};
}

export const PrevFxMode: MessageFns<PrevFxMode> = {
  encode(_: PrevFxMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrevFxMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrevFxMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PrevFxMode {
    return {};
  },

  toJSON(_: PrevFxMode): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PrevFxMode>, I>>(base?: I): PrevFxMode {
    return PrevFxMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrevFxMode>, I>>(_: I): PrevFxMode {
    const message = createBasePrevFxMode();
    return message;
  },
};

function createBaseRefreshFxMode(): RefreshFxMode {
  return {};
}

export const RefreshFxMode: MessageFns<RefreshFxMode> = {
  encode(_: RefreshFxMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshFxMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshFxMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RefreshFxMode {
    return {};
  },

  toJSON(_: RefreshFxMode): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshFxMode>, I>>(base?: I): RefreshFxMode {
    return RefreshFxMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshFxMode>, I>>(_: I): RefreshFxMode {
    const message = createBaseRefreshFxMode();
    return message;
  },
};

function createBaseHaltAll(): HaltAll {
  return {};
}

export const HaltAll: MessageFns<HaltAll> = {
  encode(_: HaltAll, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HaltAll {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHaltAll();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HaltAll {
    return {};
  },

  toJSON(_: HaltAll): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HaltAll>, I>>(base?: I): HaltAll {
    return HaltAll.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HaltAll>, I>>(_: I): HaltAll {
    const message = createBaseHaltAll();
    return message;
  },
};

function createBaseSetFxMode(): SetFxMode {
  return { mode: 0 };
}

export const SetFxMode: MessageFns<SetFxMode> = {
  encode(message: SetFxMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetFxMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetFxMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetFxMode {
    return { mode: isSet(object.mode) ? jonGuiDataFxModeDayFromJSON(object.mode) : 0 };
  },

  toJSON(message: SetFxMode): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = jonGuiDataFxModeDayToJSON(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetFxMode>, I>>(base?: I): SetFxMode {
    return SetFxMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetFxMode>, I>>(object: I): SetFxMode {
    const message = createBaseSetFxMode();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSetDigitalZoomLevel(): SetDigitalZoomLevel {
  return { value: 0 };
}

export const SetDigitalZoomLevel: MessageFns<SetDigitalZoomLevel> = {
  encode(message: SetDigitalZoomLevel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetDigitalZoomLevel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetDigitalZoomLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetDigitalZoomLevel {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: SetDigitalZoomLevel): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetDigitalZoomLevel>, I>>(base?: I): SetDigitalZoomLevel {
    return SetDigitalZoomLevel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetDigitalZoomLevel>, I>>(object: I): SetDigitalZoomLevel {
    const message = createBaseSetDigitalZoomLevel();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseFocus(): Focus {
  return {
    setValue: undefined,
    move: undefined,
    halt: undefined,
    offset: undefined,
    resetFocus: undefined,
    saveToTableFocus: undefined,
  };
}

export const Focus: MessageFns<Focus> = {
  encode(message: Focus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.setValue !== undefined) {
      SetValue.encode(message.setValue, writer.uint32(10).fork()).join();
    }
    if (message.move !== undefined) {
      Move.encode(message.move, writer.uint32(18).fork()).join();
    }
    if (message.halt !== undefined) {
      Halt.encode(message.halt, writer.uint32(26).fork()).join();
    }
    if (message.offset !== undefined) {
      Offset.encode(message.offset, writer.uint32(34).fork()).join();
    }
    if (message.resetFocus !== undefined) {
      ResetFocus.encode(message.resetFocus, writer.uint32(42).fork()).join();
    }
    if (message.saveToTableFocus !== undefined) {
      SaveToTableFocus.encode(message.saveToTableFocus, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Focus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFocus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.setValue = SetValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.move = Move.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.halt = Halt.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.offset = Offset.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resetFocus = ResetFocus.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.saveToTableFocus = SaveToTableFocus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Focus {
    return {
      setValue: isSet(object.setValue) ? SetValue.fromJSON(object.setValue) : undefined,
      move: isSet(object.move) ? Move.fromJSON(object.move) : undefined,
      halt: isSet(object.halt) ? Halt.fromJSON(object.halt) : undefined,
      offset: isSet(object.offset) ? Offset.fromJSON(object.offset) : undefined,
      resetFocus: isSet(object.resetFocus) ? ResetFocus.fromJSON(object.resetFocus) : undefined,
      saveToTableFocus: isSet(object.saveToTableFocus) ? SaveToTableFocus.fromJSON(object.saveToTableFocus) : undefined,
    };
  },

  toJSON(message: Focus): unknown {
    const obj: any = {};
    if (message.setValue !== undefined) {
      obj.setValue = SetValue.toJSON(message.setValue);
    }
    if (message.move !== undefined) {
      obj.move = Move.toJSON(message.move);
    }
    if (message.halt !== undefined) {
      obj.halt = Halt.toJSON(message.halt);
    }
    if (message.offset !== undefined) {
      obj.offset = Offset.toJSON(message.offset);
    }
    if (message.resetFocus !== undefined) {
      obj.resetFocus = ResetFocus.toJSON(message.resetFocus);
    }
    if (message.saveToTableFocus !== undefined) {
      obj.saveToTableFocus = SaveToTableFocus.toJSON(message.saveToTableFocus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Focus>, I>>(base?: I): Focus {
    return Focus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Focus>, I>>(object: I): Focus {
    const message = createBaseFocus();
    message.setValue = (object.setValue !== undefined && object.setValue !== null)
      ? SetValue.fromPartial(object.setValue)
      : undefined;
    message.move = (object.move !== undefined && object.move !== null) ? Move.fromPartial(object.move) : undefined;
    message.halt = (object.halt !== undefined && object.halt !== null) ? Halt.fromPartial(object.halt) : undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Offset.fromPartial(object.offset)
      : undefined;
    message.resetFocus = (object.resetFocus !== undefined && object.resetFocus !== null)
      ? ResetFocus.fromPartial(object.resetFocus)
      : undefined;
    message.saveToTableFocus = (object.saveToTableFocus !== undefined && object.saveToTableFocus !== null)
      ? SaveToTableFocus.fromPartial(object.saveToTableFocus)
      : undefined;
    return message;
  },
};

function createBaseZoom(): Zoom {
  return {
    setValue: undefined,
    move: undefined,
    halt: undefined,
    setZoomTableValue: undefined,
    nextZoomTablePos: undefined,
    prevZoomTablePos: undefined,
    offset: undefined,
    resetZoom: undefined,
    saveToTable: undefined,
  };
}

export const Zoom: MessageFns<Zoom> = {
  encode(message: Zoom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.setValue !== undefined) {
      SetValue.encode(message.setValue, writer.uint32(10).fork()).join();
    }
    if (message.move !== undefined) {
      Move.encode(message.move, writer.uint32(18).fork()).join();
    }
    if (message.halt !== undefined) {
      Halt.encode(message.halt, writer.uint32(26).fork()).join();
    }
    if (message.setZoomTableValue !== undefined) {
      SetZoomTableValue.encode(message.setZoomTableValue, writer.uint32(34).fork()).join();
    }
    if (message.nextZoomTablePos !== undefined) {
      NextZoomTablePos.encode(message.nextZoomTablePos, writer.uint32(42).fork()).join();
    }
    if (message.prevZoomTablePos !== undefined) {
      PrevZoomTablePos.encode(message.prevZoomTablePos, writer.uint32(50).fork()).join();
    }
    if (message.offset !== undefined) {
      Offset.encode(message.offset, writer.uint32(58).fork()).join();
    }
    if (message.resetZoom !== undefined) {
      ResetZoom.encode(message.resetZoom, writer.uint32(66).fork()).join();
    }
    if (message.saveToTable !== undefined) {
      SaveToTable.encode(message.saveToTable, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Zoom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZoom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.setValue = SetValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.move = Move.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.halt = Halt.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.setZoomTableValue = SetZoomTableValue.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nextZoomTablePos = NextZoomTablePos.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.prevZoomTablePos = PrevZoomTablePos.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.offset = Offset.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resetZoom = ResetZoom.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.saveToTable = SaveToTable.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Zoom {
    return {
      setValue: isSet(object.setValue) ? SetValue.fromJSON(object.setValue) : undefined,
      move: isSet(object.move) ? Move.fromJSON(object.move) : undefined,
      halt: isSet(object.halt) ? Halt.fromJSON(object.halt) : undefined,
      setZoomTableValue: isSet(object.setZoomTableValue)
        ? SetZoomTableValue.fromJSON(object.setZoomTableValue)
        : undefined,
      nextZoomTablePos: isSet(object.nextZoomTablePos) ? NextZoomTablePos.fromJSON(object.nextZoomTablePos) : undefined,
      prevZoomTablePos: isSet(object.prevZoomTablePos) ? PrevZoomTablePos.fromJSON(object.prevZoomTablePos) : undefined,
      offset: isSet(object.offset) ? Offset.fromJSON(object.offset) : undefined,
      resetZoom: isSet(object.resetZoom) ? ResetZoom.fromJSON(object.resetZoom) : undefined,
      saveToTable: isSet(object.saveToTable) ? SaveToTable.fromJSON(object.saveToTable) : undefined,
    };
  },

  toJSON(message: Zoom): unknown {
    const obj: any = {};
    if (message.setValue !== undefined) {
      obj.setValue = SetValue.toJSON(message.setValue);
    }
    if (message.move !== undefined) {
      obj.move = Move.toJSON(message.move);
    }
    if (message.halt !== undefined) {
      obj.halt = Halt.toJSON(message.halt);
    }
    if (message.setZoomTableValue !== undefined) {
      obj.setZoomTableValue = SetZoomTableValue.toJSON(message.setZoomTableValue);
    }
    if (message.nextZoomTablePos !== undefined) {
      obj.nextZoomTablePos = NextZoomTablePos.toJSON(message.nextZoomTablePos);
    }
    if (message.prevZoomTablePos !== undefined) {
      obj.prevZoomTablePos = PrevZoomTablePos.toJSON(message.prevZoomTablePos);
    }
    if (message.offset !== undefined) {
      obj.offset = Offset.toJSON(message.offset);
    }
    if (message.resetZoom !== undefined) {
      obj.resetZoom = ResetZoom.toJSON(message.resetZoom);
    }
    if (message.saveToTable !== undefined) {
      obj.saveToTable = SaveToTable.toJSON(message.saveToTable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Zoom>, I>>(base?: I): Zoom {
    return Zoom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Zoom>, I>>(object: I): Zoom {
    const message = createBaseZoom();
    message.setValue = (object.setValue !== undefined && object.setValue !== null)
      ? SetValue.fromPartial(object.setValue)
      : undefined;
    message.move = (object.move !== undefined && object.move !== null) ? Move.fromPartial(object.move) : undefined;
    message.halt = (object.halt !== undefined && object.halt !== null) ? Halt.fromPartial(object.halt) : undefined;
    message.setZoomTableValue = (object.setZoomTableValue !== undefined && object.setZoomTableValue !== null)
      ? SetZoomTableValue.fromPartial(object.setZoomTableValue)
      : undefined;
    message.nextZoomTablePos = (object.nextZoomTablePos !== undefined && object.nextZoomTablePos !== null)
      ? NextZoomTablePos.fromPartial(object.nextZoomTablePos)
      : undefined;
    message.prevZoomTablePos = (object.prevZoomTablePos !== undefined && object.prevZoomTablePos !== null)
      ? PrevZoomTablePos.fromPartial(object.prevZoomTablePos)
      : undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Offset.fromPartial(object.offset)
      : undefined;
    message.resetZoom = (object.resetZoom !== undefined && object.resetZoom !== null)
      ? ResetZoom.fromPartial(object.resetZoom)
      : undefined;
    message.saveToTable = (object.saveToTable !== undefined && object.saveToTable !== null)
      ? SaveToTable.fromPartial(object.saveToTable)
      : undefined;
    return message;
  },
};

function createBaseNextZoomTablePos(): NextZoomTablePos {
  return {};
}

export const NextZoomTablePos: MessageFns<NextZoomTablePos> = {
  encode(_: NextZoomTablePos, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NextZoomTablePos {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNextZoomTablePos();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NextZoomTablePos {
    return {};
  },

  toJSON(_: NextZoomTablePos): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NextZoomTablePos>, I>>(base?: I): NextZoomTablePos {
    return NextZoomTablePos.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NextZoomTablePos>, I>>(_: I): NextZoomTablePos {
    const message = createBaseNextZoomTablePos();
    return message;
  },
};

function createBasePrevZoomTablePos(): PrevZoomTablePos {
  return {};
}

export const PrevZoomTablePos: MessageFns<PrevZoomTablePos> = {
  encode(_: PrevZoomTablePos, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrevZoomTablePos {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrevZoomTablePos();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PrevZoomTablePos {
    return {};
  },

  toJSON(_: PrevZoomTablePos): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PrevZoomTablePos>, I>>(base?: I): PrevZoomTablePos {
    return PrevZoomTablePos.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrevZoomTablePos>, I>>(_: I): PrevZoomTablePos {
    const message = createBasePrevZoomTablePos();
    return message;
  },
};

function createBaseSetIris(): SetIris {
  return { value: 0 };
}

export const SetIris: MessageFns<SetIris> = {
  encode(message: SetIris, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetIris {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetIris();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetIris {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: SetIris): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetIris>, I>>(base?: I): SetIris {
    return SetIris.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetIris>, I>>(object: I): SetIris {
    const message = createBaseSetIris();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSetInfraRedFilter(): SetInfraRedFilter {
  return { value: false };
}

export const SetInfraRedFilter: MessageFns<SetInfraRedFilter> = {
  encode(message: SetInfraRedFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== false) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetInfraRedFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetInfraRedFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetInfraRedFilter {
    return { value: isSet(object.value) ? globalThis.Boolean(object.value) : false };
  },

  toJSON(message: SetInfraRedFilter): unknown {
    const obj: any = {};
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetInfraRedFilter>, I>>(base?: I): SetInfraRedFilter {
    return SetInfraRedFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetInfraRedFilter>, I>>(object: I): SetInfraRedFilter {
    const message = createBaseSetInfraRedFilter();
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseSetAutoIris(): SetAutoIris {
  return { value: false };
}

export const SetAutoIris: MessageFns<SetAutoIris> = {
  encode(message: SetAutoIris, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== false) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAutoIris {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAutoIris();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAutoIris {
    return { value: isSet(object.value) ? globalThis.Boolean(object.value) : false };
  },

  toJSON(message: SetAutoIris): unknown {
    const obj: any = {};
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetAutoIris>, I>>(base?: I): SetAutoIris {
    return SetAutoIris.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetAutoIris>, I>>(object: I): SetAutoIris {
    const message = createBaseSetAutoIris();
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseSetZoomTableValue(): SetZoomTableValue {
  return { value: 0 };
}

export const SetZoomTableValue: MessageFns<SetZoomTableValue> = {
  encode(message: SetZoomTableValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetZoomTableValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetZoomTableValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetZoomTableValue {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: SetZoomTableValue): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetZoomTableValue>, I>>(base?: I): SetZoomTableValue {
    return SetZoomTableValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetZoomTableValue>, I>>(object: I): SetZoomTableValue {
    const message = createBaseSetZoomTableValue();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseStop(): Stop {
  return {};
}

export const Stop: MessageFns<Stop> = {
  encode(_: Stop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Stop {
    return {};
  },

  toJSON(_: Stop): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Stop>, I>>(base?: I): Stop {
    return Stop.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stop>, I>>(_: I): Stop {
    const message = createBaseStop();
    return message;
  },
};

function createBaseStart(): Start {
  return {};
}

export const Start: MessageFns<Start> = {
  encode(_: Start, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Start {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Start {
    return {};
  },

  toJSON(_: Start): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Start>, I>>(base?: I): Start {
    return Start.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Start>, I>>(_: I): Start {
    const message = createBaseStart();
    return message;
  },
};

function createBasePhoto(): Photo {
  return {};
}

export const Photo: MessageFns<Photo> = {
  encode(_: Photo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Photo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Photo {
    return {};
  },

  toJSON(_: Photo): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Photo>, I>>(base?: I): Photo {
    return Photo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Photo>, I>>(_: I): Photo {
    const message = createBasePhoto();
    return message;
  },
};

function createBaseHalt(): Halt {
  return {};
}

export const Halt: MessageFns<Halt> = {
  encode(_: Halt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Halt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHalt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Halt {
    return {};
  },

  toJSON(_: Halt): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Halt>, I>>(base?: I): Halt {
    return Halt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Halt>, I>>(_: I): Halt {
    const message = createBaseHalt();
    return message;
  },
};

function createBaseGetMeteo(): GetMeteo {
  return {};
}

export const GetMeteo: MessageFns<GetMeteo> = {
  encode(_: GetMeteo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMeteo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMeteo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetMeteo {
    return {};
  },

  toJSON(_: GetMeteo): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMeteo>, I>>(base?: I): GetMeteo {
    return GetMeteo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMeteo>, I>>(_: I): GetMeteo {
    const message = createBaseGetMeteo();
    return message;
  },
};

function createBaseResetZoom(): ResetZoom {
  return {};
}

export const ResetZoom: MessageFns<ResetZoom> = {
  encode(_: ResetZoom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetZoom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetZoom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResetZoom {
    return {};
  },

  toJSON(_: ResetZoom): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetZoom>, I>>(base?: I): ResetZoom {
    return ResetZoom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetZoom>, I>>(_: I): ResetZoom {
    const message = createBaseResetZoom();
    return message;
  },
};

function createBaseResetFocus(): ResetFocus {
  return {};
}

export const ResetFocus: MessageFns<ResetFocus> = {
  encode(_: ResetFocus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetFocus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetFocus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResetFocus {
    return {};
  },

  toJSON(_: ResetFocus): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetFocus>, I>>(base?: I): ResetFocus {
    return ResetFocus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetFocus>, I>>(_: I): ResetFocus {
    const message = createBaseResetFocus();
    return message;
  },
};

function createBaseSaveToTable(): SaveToTable {
  return {};
}

export const SaveToTable: MessageFns<SaveToTable> = {
  encode(_: SaveToTable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveToTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveToTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SaveToTable {
    return {};
  },

  toJSON(_: SaveToTable): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveToTable>, I>>(base?: I): SaveToTable {
    return SaveToTable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveToTable>, I>>(_: I): SaveToTable {
    const message = createBaseSaveToTable();
    return message;
  },
};

function createBaseSaveToTableFocus(): SaveToTableFocus {
  return {};
}

export const SaveToTableFocus: MessageFns<SaveToTableFocus> = {
  encode(_: SaveToTableFocus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveToTableFocus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveToTableFocus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SaveToTableFocus {
    return {};
  },

  toJSON(_: SaveToTableFocus): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveToTableFocus>, I>>(base?: I): SaveToTableFocus {
    return SaveToTableFocus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveToTableFocus>, I>>(_: I): SaveToTableFocus {
    const message = createBaseSaveToTableFocus();
    return message;
  },
};

function createBaseFocusAtROI(): FocusAtROI {
  return { x: 0, y: 0 };
}

export const FocusAtROI: MessageFns<FocusAtROI> = {
  encode(message: FocusAtROI, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FocusAtROI {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFocusAtROI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FocusAtROI {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: FocusAtROI): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FocusAtROI>, I>>(base?: I): FocusAtROI {
    return FocusAtROI.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FocusAtROI>, I>>(object: I): FocusAtROI {
    const message = createBaseFocusAtROI();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseTrackROI(): TrackROI {
  return { x1: 0, y1: 0, x2: 0, y2: 0 };
}

export const TrackROI: MessageFns<TrackROI> = {
  encode(message: TrackROI, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x1 !== 0) {
      writer.uint32(9).double(message.x1);
    }
    if (message.y1 !== 0) {
      writer.uint32(17).double(message.y1);
    }
    if (message.x2 !== 0) {
      writer.uint32(25).double(message.x2);
    }
    if (message.y2 !== 0) {
      writer.uint32(33).double(message.y2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackROI {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackROI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.x1 = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.y1 = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.x2 = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.y2 = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackROI {
    return {
      x1: isSet(object.x1) ? globalThis.Number(object.x1) : 0,
      y1: isSet(object.y1) ? globalThis.Number(object.y1) : 0,
      x2: isSet(object.x2) ? globalThis.Number(object.x2) : 0,
      y2: isSet(object.y2) ? globalThis.Number(object.y2) : 0,
    };
  },

  toJSON(message: TrackROI): unknown {
    const obj: any = {};
    if (message.x1 !== 0) {
      obj.x1 = message.x1;
    }
    if (message.y1 !== 0) {
      obj.y1 = message.y1;
    }
    if (message.x2 !== 0) {
      obj.x2 = message.x2;
    }
    if (message.y2 !== 0) {
      obj.y2 = message.y2;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackROI>, I>>(base?: I): TrackROI {
    return TrackROI.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackROI>, I>>(object: I): TrackROI {
    const message = createBaseTrackROI();
    message.x1 = object.x1 ?? 0;
    message.y1 = object.y1 ?? 0;
    message.x2 = object.x2 ?? 0;
    message.y2 = object.y2 ?? 0;
    return message;
  },
};

function createBaseZoomROI(): ZoomROI {
  return { x1: 0, y1: 0, x2: 0, y2: 0 };
}

export const ZoomROI: MessageFns<ZoomROI> = {
  encode(message: ZoomROI, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x1 !== 0) {
      writer.uint32(9).double(message.x1);
    }
    if (message.y1 !== 0) {
      writer.uint32(17).double(message.y1);
    }
    if (message.x2 !== 0) {
      writer.uint32(25).double(message.x2);
    }
    if (message.y2 !== 0) {
      writer.uint32(33).double(message.y2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZoomROI {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZoomROI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.x1 = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.y1 = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.x2 = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.y2 = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZoomROI {
    return {
      x1: isSet(object.x1) ? globalThis.Number(object.x1) : 0,
      y1: isSet(object.y1) ? globalThis.Number(object.y1) : 0,
      x2: isSet(object.x2) ? globalThis.Number(object.x2) : 0,
      y2: isSet(object.y2) ? globalThis.Number(object.y2) : 0,
    };
  },

  toJSON(message: ZoomROI): unknown {
    const obj: any = {};
    if (message.x1 !== 0) {
      obj.x1 = message.x1;
    }
    if (message.y1 !== 0) {
      obj.y1 = message.y1;
    }
    if (message.x2 !== 0) {
      obj.x2 = message.x2;
    }
    if (message.y2 !== 0) {
      obj.y2 = message.y2;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ZoomROI>, I>>(base?: I): ZoomROI {
    return ZoomROI.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ZoomROI>, I>>(object: I): ZoomROI {
    const message = createBaseZoomROI();
    message.x1 = object.x1 ?? 0;
    message.y1 = object.y1 ?? 0;
    message.x2 = object.x2 ?? 0;
    message.y2 = object.y2 ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
