// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v5.29.2
// source: jon_shared_data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { JonGuiDataActualSpaceTime } from "./jon_shared_data_actual_space_time";
import { JonGuiDataCameraDay } from "./jon_shared_data_camera_day";
import { JonGuiDataCameraHeat } from "./jon_shared_data_camera_heat";
import { JonGuiDataCompass } from "./jon_shared_data_compass";
import { JonGuiDataCompassCalibration } from "./jon_shared_data_compass_calibration";
import { JonGuiDataDayCamGlassHeater } from "./jon_shared_data_day_cam_glass_heater";
import { JonGuiDataGps } from "./jon_shared_data_gps";
import { JonGuiDataLrf } from "./jon_shared_data_lrf";
import { JonGuiDataRecOsd } from "./jon_shared_data_rec_osd";
import { JonGuiDataRotary } from "./jon_shared_data_rotary";
import { JonGuiDataSystem } from "./jon_shared_data_system";
import { JonGuiDataTime } from "./jon_shared_data_time";
import { JonGuiDataMeteo } from "./jon_shared_data_types";

/** Root message */
export interface JonGUIState {
  protocolVersion: number;
  /** System monotonic time in microseconds */
  systemMonotonicTimeUs: Long;
  system: JonGuiDataSystem | undefined;
  meteoInternal: JonGuiDataMeteo | undefined;
  lrf: JonGuiDataLrf | undefined;
  time: JonGuiDataTime | undefined;
  gps: JonGuiDataGps | undefined;
  compass: JonGuiDataCompass | undefined;
  rotary: JonGuiDataRotary | undefined;
  cameraDay: JonGuiDataCameraDay | undefined;
  cameraHeat: JonGuiDataCameraHeat | undefined;
  compassCalibration: JonGuiDataCompassCalibration | undefined;
  recOsd: JonGuiDataRecOsd | undefined;
  dayCamGlassHeater: JonGuiDataDayCamGlassHeater | undefined;
  actualSpaceTime: JonGuiDataActualSpaceTime | undefined;
}

function createBaseJonGUIState(): JonGUIState {
  return {
    protocolVersion: 0,
    systemMonotonicTimeUs: Long.UZERO,
    system: undefined,
    meteoInternal: undefined,
    lrf: undefined,
    time: undefined,
    gps: undefined,
    compass: undefined,
    rotary: undefined,
    cameraDay: undefined,
    cameraHeat: undefined,
    compassCalibration: undefined,
    recOsd: undefined,
    dayCamGlassHeater: undefined,
    actualSpaceTime: undefined,
  };
}

export const JonGUIState: MessageFns<JonGUIState> = {
  encode(message: JonGUIState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolVersion !== 0) {
      writer.uint32(8).uint32(message.protocolVersion);
    }
    if (!message.systemMonotonicTimeUs.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.systemMonotonicTimeUs.toString());
    }
    if (message.system !== undefined) {
      JonGuiDataSystem.encode(message.system, writer.uint32(106).fork()).join();
    }
    if (message.meteoInternal !== undefined) {
      JonGuiDataMeteo.encode(message.meteoInternal, writer.uint32(114).fork()).join();
    }
    if (message.lrf !== undefined) {
      JonGuiDataLrf.encode(message.lrf, writer.uint32(122).fork()).join();
    }
    if (message.time !== undefined) {
      JonGuiDataTime.encode(message.time, writer.uint32(130).fork()).join();
    }
    if (message.gps !== undefined) {
      JonGuiDataGps.encode(message.gps, writer.uint32(138).fork()).join();
    }
    if (message.compass !== undefined) {
      JonGuiDataCompass.encode(message.compass, writer.uint32(146).fork()).join();
    }
    if (message.rotary !== undefined) {
      JonGuiDataRotary.encode(message.rotary, writer.uint32(154).fork()).join();
    }
    if (message.cameraDay !== undefined) {
      JonGuiDataCameraDay.encode(message.cameraDay, writer.uint32(162).fork()).join();
    }
    if (message.cameraHeat !== undefined) {
      JonGuiDataCameraHeat.encode(message.cameraHeat, writer.uint32(170).fork()).join();
    }
    if (message.compassCalibration !== undefined) {
      JonGuiDataCompassCalibration.encode(message.compassCalibration, writer.uint32(178).fork()).join();
    }
    if (message.recOsd !== undefined) {
      JonGuiDataRecOsd.encode(message.recOsd, writer.uint32(186).fork()).join();
    }
    if (message.dayCamGlassHeater !== undefined) {
      JonGuiDataDayCamGlassHeater.encode(message.dayCamGlassHeater, writer.uint32(194).fork()).join();
    }
    if (message.actualSpaceTime !== undefined) {
      JonGuiDataActualSpaceTime.encode(message.actualSpaceTime, writer.uint32(202).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JonGUIState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJonGUIState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocolVersion = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.systemMonotonicTimeUs = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.system = JonGuiDataSystem.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.meteoInternal = JonGuiDataMeteo.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.lrf = JonGuiDataLrf.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.time = JonGuiDataTime.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.gps = JonGuiDataGps.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.compass = JonGuiDataCompass.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.rotary = JonGuiDataRotary.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.cameraDay = JonGuiDataCameraDay.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.cameraHeat = JonGuiDataCameraHeat.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.compassCalibration = JonGuiDataCompassCalibration.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.recOsd = JonGuiDataRecOsd.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.dayCamGlassHeater = JonGuiDataDayCamGlassHeater.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.actualSpaceTime = JonGuiDataActualSpaceTime.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JonGUIState {
    return {
      protocolVersion: isSet(object.protocolVersion) ? globalThis.Number(object.protocolVersion) : 0,
      systemMonotonicTimeUs: isSet(object.systemMonotonicTimeUs)
        ? Long.fromValue(object.systemMonotonicTimeUs)
        : Long.UZERO,
      system: isSet(object.system) ? JonGuiDataSystem.fromJSON(object.system) : undefined,
      meteoInternal: isSet(object.meteoInternal) ? JonGuiDataMeteo.fromJSON(object.meteoInternal) : undefined,
      lrf: isSet(object.lrf) ? JonGuiDataLrf.fromJSON(object.lrf) : undefined,
      time: isSet(object.time) ? JonGuiDataTime.fromJSON(object.time) : undefined,
      gps: isSet(object.gps) ? JonGuiDataGps.fromJSON(object.gps) : undefined,
      compass: isSet(object.compass) ? JonGuiDataCompass.fromJSON(object.compass) : undefined,
      rotary: isSet(object.rotary) ? JonGuiDataRotary.fromJSON(object.rotary) : undefined,
      cameraDay: isSet(object.cameraDay) ? JonGuiDataCameraDay.fromJSON(object.cameraDay) : undefined,
      cameraHeat: isSet(object.cameraHeat) ? JonGuiDataCameraHeat.fromJSON(object.cameraHeat) : undefined,
      compassCalibration: isSet(object.compassCalibration)
        ? JonGuiDataCompassCalibration.fromJSON(object.compassCalibration)
        : undefined,
      recOsd: isSet(object.recOsd) ? JonGuiDataRecOsd.fromJSON(object.recOsd) : undefined,
      dayCamGlassHeater: isSet(object.dayCamGlassHeater)
        ? JonGuiDataDayCamGlassHeater.fromJSON(object.dayCamGlassHeater)
        : undefined,
      actualSpaceTime: isSet(object.actualSpaceTime)
        ? JonGuiDataActualSpaceTime.fromJSON(object.actualSpaceTime)
        : undefined,
    };
  },

  toJSON(message: JonGUIState): unknown {
    const obj: any = {};
    if (message.protocolVersion !== 0) {
      obj.protocolVersion = Math.round(message.protocolVersion);
    }
    if (!message.systemMonotonicTimeUs.equals(Long.UZERO)) {
      obj.systemMonotonicTimeUs = (message.systemMonotonicTimeUs || Long.UZERO).toString();
    }
    if (message.system !== undefined) {
      obj.system = JonGuiDataSystem.toJSON(message.system);
    }
    if (message.meteoInternal !== undefined) {
      obj.meteoInternal = JonGuiDataMeteo.toJSON(message.meteoInternal);
    }
    if (message.lrf !== undefined) {
      obj.lrf = JonGuiDataLrf.toJSON(message.lrf);
    }
    if (message.time !== undefined) {
      obj.time = JonGuiDataTime.toJSON(message.time);
    }
    if (message.gps !== undefined) {
      obj.gps = JonGuiDataGps.toJSON(message.gps);
    }
    if (message.compass !== undefined) {
      obj.compass = JonGuiDataCompass.toJSON(message.compass);
    }
    if (message.rotary !== undefined) {
      obj.rotary = JonGuiDataRotary.toJSON(message.rotary);
    }
    if (message.cameraDay !== undefined) {
      obj.cameraDay = JonGuiDataCameraDay.toJSON(message.cameraDay);
    }
    if (message.cameraHeat !== undefined) {
      obj.cameraHeat = JonGuiDataCameraHeat.toJSON(message.cameraHeat);
    }
    if (message.compassCalibration !== undefined) {
      obj.compassCalibration = JonGuiDataCompassCalibration.toJSON(message.compassCalibration);
    }
    if (message.recOsd !== undefined) {
      obj.recOsd = JonGuiDataRecOsd.toJSON(message.recOsd);
    }
    if (message.dayCamGlassHeater !== undefined) {
      obj.dayCamGlassHeater = JonGuiDataDayCamGlassHeater.toJSON(message.dayCamGlassHeater);
    }
    if (message.actualSpaceTime !== undefined) {
      obj.actualSpaceTime = JonGuiDataActualSpaceTime.toJSON(message.actualSpaceTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JonGUIState>, I>>(base?: I): JonGUIState {
    return JonGUIState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JonGUIState>, I>>(object: I): JonGUIState {
    const message = createBaseJonGUIState();
    message.protocolVersion = object.protocolVersion ?? 0;
    message.systemMonotonicTimeUs =
      (object.systemMonotonicTimeUs !== undefined && object.systemMonotonicTimeUs !== null)
        ? Long.fromValue(object.systemMonotonicTimeUs)
        : Long.UZERO;
    message.system = (object.system !== undefined && object.system !== null)
      ? JonGuiDataSystem.fromPartial(object.system)
      : undefined;
    message.meteoInternal = (object.meteoInternal !== undefined && object.meteoInternal !== null)
      ? JonGuiDataMeteo.fromPartial(object.meteoInternal)
      : undefined;
    message.lrf = (object.lrf !== undefined && object.lrf !== null) ? JonGuiDataLrf.fromPartial(object.lrf) : undefined;
    message.time = (object.time !== undefined && object.time !== null)
      ? JonGuiDataTime.fromPartial(object.time)
      : undefined;
    message.gps = (object.gps !== undefined && object.gps !== null) ? JonGuiDataGps.fromPartial(object.gps) : undefined;
    message.compass = (object.compass !== undefined && object.compass !== null)
      ? JonGuiDataCompass.fromPartial(object.compass)
      : undefined;
    message.rotary = (object.rotary !== undefined && object.rotary !== null)
      ? JonGuiDataRotary.fromPartial(object.rotary)
      : undefined;
    message.cameraDay = (object.cameraDay !== undefined && object.cameraDay !== null)
      ? JonGuiDataCameraDay.fromPartial(object.cameraDay)
      : undefined;
    message.cameraHeat = (object.cameraHeat !== undefined && object.cameraHeat !== null)
      ? JonGuiDataCameraHeat.fromPartial(object.cameraHeat)
      : undefined;
    message.compassCalibration = (object.compassCalibration !== undefined && object.compassCalibration !== null)
      ? JonGuiDataCompassCalibration.fromPartial(object.compassCalibration)
      : undefined;
    message.recOsd = (object.recOsd !== undefined && object.recOsd !== null)
      ? JonGuiDataRecOsd.fromPartial(object.recOsd)
      : undefined;
    message.dayCamGlassHeater = (object.dayCamGlassHeater !== undefined && object.dayCamGlassHeater !== null)
      ? JonGuiDataDayCamGlassHeater.fromPartial(object.dayCamGlassHeater)
      : undefined;
    message.actualSpaceTime = (object.actualSpaceTime !== undefined && object.actualSpaceTime !== null)
      ? JonGuiDataActualSpaceTime.fromPartial(object.actualSpaceTime)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
